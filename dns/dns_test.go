package dns

import (
	"testing"
)

func TestMakeLookupFunc(t *testing.T) {
	// Rules generated by NewDNSRule() in operator for KurrentDB like:
	//
	//    db := &v1.KurrentDB{
	//        ObjectMeta: metav1.ObjectMeta{
	//            Name: "kdb",
	//            Namespace: "ns",
	//        },
	//        Spec: v1.KurrentDBSpec{
	//            Image: imageName,
	//            Network: v1.KurrentDBNetworkSpec {
	//                Domain: "my-domain",
	//                // an insane FQDNTemplate to make sure our template parsing and regex escaping works
	//                FQDNTemplate: `x\({podName}|y.another-{podName}.{domain}`,
	//            },
	//        },
	//    }

	rule1 := DNSRule{
		Regex:  true,
		Host:   `x\\\(kdb-([0-9]+)\|y\.another-kdb-([0-9]+)\.my-domain`,
		Result: "kdb-${1}.kdb.ns.svc.cluster.local",
	}
	rule2 := DNSRule{
		Regex:  true,
		Host:   `x\\\(kdb-replica-([0-9]+)\|y\.another-kdb-replica-([0-9]+)\.my-domain`,
		Result: "kdb-replica-${1}.kdb-replica.ns.svc.cluster.local",
	}

	lookupFn, err := MakeLookupFunc([]DNSRule{rule1, rule2})
	if err != nil {
		t.Fatalf("MakeLookupFunc: %v", err)
	}

	type Case struct {
		FQDN    string
		BadFQDN string
		Service string
	}

	for i, tc := range []Case{
		{
			FQDN:    "x\\(kdb-0|y.another-kdb-0.my-domain",
			BadFQDN: "x\\(kdb-|y.another-kdb-.my-domain",
			Service: "kdb-0.kdb.ns.svc.cluster.local",
		},
		{
			FQDN:    "x\\(kdb-1|y.another-kdb-1.my-domain",
			BadFQDN: "x\\(kdb-|y.another-kdb-.my-domain",
			Service: "kdb-1.kdb.ns.svc.cluster.local",
		},
		{
			FQDN:    "x\\(kdb-2|y.another-kdb-2.my-domain",
			BadFQDN: "x\\(kdb-|y.another-kdb-.my-domain",
			Service: "kdb-2.kdb.ns.svc.cluster.local",
		},
		{
			FQDN:    "x\\(kdb-replica-0|y.another-kdb-replica-0.my-domain",
			BadFQDN: "x\\(kdb-replica-|y.another-kdb-replica-.my-domain",
			Service: "kdb-replica-0.kdb-replica.ns.svc.cluster.local",
		},
		{
			FQDN:    "x\\(kdb-replica-1|y.another-kdb-replica-1.my-domain",
			BadFQDN: "x\\(kdb-replica-|y.another-kdb-replica-.my-domain",
			Service: "kdb-replica-1.kdb-replica.ns.svc.cluster.local",
		},
	} {
		result, ok := lookupFn(tc.FQDN)
		if !ok {
			t.Fatalf("lookup function did not match for case %v (%v)", i, tc.FQDN)
		}
		if result != tc.Service {
			t.Fatalf(
				"wrong answer for case %v (fqdn=%v, exp=%v, got=%v)",
				i, tc.FQDN, result, tc.Service,
			)
		}
		result, ok = lookupFn(tc.BadFQDN)
		if ok {
			t.Fatalf(
				"lookup function wrongly matched case %v (badfqdn=%v, result=%v)",
				i, tc.BadFQDN, result,
			)
		}
	}
}
